# [C++ 核心指南](https.//github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md)

# 01. P: 理念

## P.1: 在代码中直接表达你的想法

要 表达 做什么，而不是 怎么做

例子：

``` cpp
class Date {
public:
    Month month() const;  // 好
    int month();          // 不好
    // ...
};
```

例子：

``` cpp
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    auto p = find(begin(v), end(v), val);  // 不要 在这里写 函数find 的 实现代码
    // ...
}
```

例子：

``` cpp
change_speed(double s);   // bad: s 代表什么？
// ...
change_speed(2.3);

// 明确给出 double 的含义（新速度 还是 旧速度增量）以及 单位：

change_speed(Speed s);    // 好多了：说明了 s 的含义
// ...
change_speed(2.3);        // 错误：没有单位

// 如果绝对速度值和增量值都需要的话，我们应当定义一个 Delta 类型。
change_speed(23_m / 10s);  // 米每秒
```

## P.2: 用 ISO 标准 C++

使用 最新版 C++编译器(C++ 17/ C++ 20), 打开 “禁用语言扩展” 选项

## P.3: 表达你的设计意图

``` cpp
for (const auto& x : v) { 
    /* 用 x 的值做一些事 */ 
}

for (auto& x : v) { 
    /* 修改 x */ 
}

for_each(v, [](int x) { 
    /* 用 x 的值做一些事 */ 
});

for_each(par, v, [](int x) { 
    /* 用 x 的值做一些事，并行 */ 
});
```

## P.4: 理想情况下，程序应当完全是静态（编译期）类型安全的

例外 及 替代：

+ union: 用 variant（C++17 ）
+ 强制转换: 尽可能 减少使用，使用模板有助于这点
+ 数组退化: 使用 gsl::span
+ 范围错误: 使用 gsl::span
+ 窄化转换: 尽可能 减少使用，使用：gsl::narrow 或 gsl::narrow_cast

## P.5: 编译期检查优先于运行时检查



## P.6: 应当使无法在编译期进行的检查能够在运行时实施
## P.7: 尽早识别运行时错误
## P.8: 不要泄漏任何资源
## P.9: 不要浪费时间或空间
## P.10: 不可变数据优先于可变数据
## P.11: 把杂乱的构造封装起来，而别让其散布到代码中
## P.12: 适当采用支持工具
## P.13: 适当采用支持程序库

# 02. 接口

# 03. 函数

# 04. 类和类层次

# 05. 枚举

# 06. 资源管理

# 07. 表达式和语句

# 08. 性能

# 09. 并发与并行

## CP.1: 假定你的代码将作为多线程程序的一部分而运行
## CP.2: 避免数据竞争
## CP.3: 最小化可写数据的明确共享
## CP.4: 以任务而不是线程的角度思考
## CP.8: 不要为同步而使用 volatile
## CP.9: 只要可行，就使用工具对并发代码进行验证

参见：

CP.con: 并发
CP.coro: 协程
CP.par: 并行
CP.mess: 消息传递
CP.vec: 向量化
CP.free: 无锁编程
CP.etc: 其他并发规则

# 10. 错误处理

涉及：

## 检测某个错误
## 将有关错误的信息传递给某个处理代码
## 维持程序的某个有效状态
## 避免资源泄漏
## 不可能做到从所有的错误中恢复: 以明确定义的方式迅速“脱离”则是很重要的

避免几种错误 的：

## 类型违规（比如对 union 和强制转换的误用）
## 资源泄漏（包括内存泄漏）
## 边界错误
## 生存期错误（比如在对象被 delete 后访问它）
## 复杂性错误（可能由于过于复杂的想法表达而导致的逻辑错误）
## 接口错误（比如通过接口传递了预期外的值）

错误处理：

## E.1: 在设计中尽早开发错误处理策略
## E.2: 通过抛出异常来明示函数无法完成其所赋予的任务
## E.3: 仅使用异常来进行错误处理
## E.4: 围绕不变式来设计错误处理策略
## E.5: 让构造函数建立不变式，若其无法做到则抛出异常
## E.6: 使用 RAII 来避免泄漏
## E.7: 明示前条件
## E.8: 明示后条件
## E.12: 当函数不可能或不能接受以 throw 来退出时，使用 noexcept
## E.13: 不要在作为某个对象的直接所有者时抛出异常
## E.14: 应当使用为目的所设计的自定义类型（而不是内建类型）作为异常
## E.15: 按值抛出并按引用捕获类型层次中的异常
## E.16: 析构函数，回收函数，swap，以及异常类型的复制/移动构造决不能失败
## E.17: 不要试图在每个函数中捕获每个异常
## E.18: 最小化对 try/catch 的显式使用
## E.19: 当没有合适的资源包装时，使用 final_action 对象来表达清理动作
## E.25: 当不能抛出异常时，模拟 RAII 来进行资源管理
## E.26: 当不能抛出异常时，考虑采取快速失败
## E.27: 当不能抛出异常时，系统化地使用错误代码
## E.28: 避免基于全局状态（比如 errno）的错误处理
## E.30: 请勿使用异常说明
## E.31: 恰当地对 catch 子句排序

# 11. 常量和不可变性

## Con.1: 缺省情况下，对象应当是不可变的
## Con.2: 缺省情况下，成员函数应当为 const
## Con.3: 缺省情况下，应当传递指向 const 对象的指针或引用
## Con.4: 构造之后不再改变其值的对象应当以 const 来定义
## Con.5: 以 constexpr 来定义可以在编译期计算的值

# 12. 模板和泛型编程

泛型，概念，元编程

模板使用：

## T.1: 用模板来提升代码的抽象层次
## T.2: 用模板来表达适用于许多参数类型的算法
## T.3: 用模板来表达容器和范围
## T.4: 用模板来表达对语法树的操作
## T.5: 结合泛型和面向对象技术来增强它们的能力，而不是它们的成本

概念使用：

## T.10: 为所有模板实参指明概念
## T.11: 尽可能采用标准概念
## T.12: 对于局部变量，优先采用概念名而不是 auto
## T.13: 对于简单的单类型参数概念，优先采用简写形式

概念定义：

## T.20: 避免没有有意义的语义的“概念”
## T.21: 为概念提出一组完整的操作要求
## T.22: 为概念指明公理
## T.23: 通过添加新的使用模式，从更一般情形的概念中区分出提炼后的概念
## T.24: 用标签类或特征类来区分仅在语义上存在差别的概念
## T.25: 避免互补性的约束
## T.26: 优先采用使用模式而不是简单的语法来定义概念
## T.30: 节制地采用概念求反（!C<T>）来表示微小差异
## T.31: 节制地采用概念析取（disjunction）（C1<T> || C2<T>）来表示备选项

模板接口：

## T.40: 使用函数对象向算法传递操作
## T.41: 在模板的概念上仅提出基本的性质要求
## T.42: 使用模板别名来简化写法并隐藏实现细节
## T.43: 优先使用 using 而不是 typedef 来定义别名
## T.44: （如果可行）使用函数模板来对类模板的参数类型进行推断
## T.46: 要求模板参数至少是半正规的
## T.47: 避免用常用名字命名高度可见的无约束模板
## T.48: 如果你的编译器不支持概念的话，可以用 enable_if 来模拟
## T.49: 尽可能避免类型擦除

模板定义：

## T.60: 最小化模板的上下文依赖性
## T.61: 请勿对成员进行过度参数化（SCARY）
## T.62: 将无依赖的类模板成员置于一个非模板基类之中
## T.64: 用特化来提供类模板的其他实现
## T.65: 用标签分派来提供函数的其他实现
## T.67: 用特化来提供不规则类型的其他实现
## T.68: 在模板中用 {} 而不是 () 以避免歧义
## T.69: 在模板中，请勿进行未限定的非成员函数调用，除非有意将之作为定制点

模板 和 类型层次：

## T.80: 请勿不成熟地对类层次进行模板化
## T.81: 请勿混合类层次和数组 // ??? 放在“类型层次”部分
## T.82: 当不想要虚函数时，可以将类层次线性化
## T.83: 请勿声明虚的成员函数模板
## T.84: 使用非模板的核心实现来提供 ABI 稳定的接口

变参模板：

## T.100: 当需要可以接受可变数量的多种类型参数的函数时，使用变参模板
## T.101: ??? 如何向变参模板传递参数 ???
## T.102: ??? 如何处理变参模板的参数 ???
## T.103: 请勿对同质参数列表使用变参模板

元编程：

## T.120: 仅当确实需要时才使用模板元编程
## T.121: 模板元编程主要用于模拟概念机制
## T.122: 用模板（通常为模板别名）来在编译期进行类型运算
## T.123: 用 constexpr 函数来在编译期进行值运算
## T.124: 优先使用标准库的模板元编程设施
## T.125: 当需要标准库之外的模板元编程设施时，使用某个现存程序库

其他模板 规则：

## T.140: 若操作可被重用，则应为其命名
## T.141: 当仅在一个地方需要一个简单的函数对象时，使用无名的 lambda
## T.142: 使用模板变量以简化写法
## T.143: 请勿编写并非有意非泛型的代码
## T.144: 请勿特化函数模板
## T.150: 用 static_assert 来检查类是否与概念相符

# 13. C 风格的编程

## 01: 优先使用 C++# 而不是 C
## 02: 当一定要用 C 时，应使用 C 和 C++# 的公共子集，并将 C 代码以 C++# 来编译
## 03: 当一定要用 C 来作为接口时，应在使用这些接口的调用方代码中使用 C++

# 14. 源文件

## 01. 如果你的项目还未采用别的约定的话，应当为代码文件使用后缀 .cpp，而对接口文件使用后缀 .h
## 02. 头文件不能含有对象定义或非内联的函数定义
## 03. 对在多个源文件中使用的任何声明，都应使用头文件
## 04. 在文件中的其他所有声明之前包含头文件
## 05. .cpp 文件必须包含定义了它的接口的一个或多个头文件
## 06. using namespace 指令，（仅）可以为迁移而使用，可以为基础程序库使用（比如 std），或者在局部作用域中使用
## 07. 请勿在头文件中的全局作用域使用 using namespace 指令
## 08. 为所有的头文件使用 #include 防卫宏
## 09. 避免源文件的循环依赖
## 10. 避免依赖于隐含地 #include 进来的名字
## 11. 头文件应当是自包含的
## 12. 对相对于包含文件的文件优先采用引号形式的 #include，其他情况下采用角括号形式
## 20. 用 namespace 表示逻辑结构
## 21. 请勿在头文件中使用无名（匿名）命名空间
## 22. 为所有的内部/不导出的实体使用无名（匿名）命名空间

# 15. 标准库

## 01. 尽可能使用程序库
## 02. 优先使用 标准库
## 03. 请勿向 命名空间 std 中添加 非标准实体
## 04. 以 类型安全的方式 使用 标准库
## 05. 容器
    - 01. 优先采用 STL 的 array 或 vector 而不是 C 数组
    - 02. 除非有理由使用别的容器，否则默认情况应优先采用 STL 的 vector
    - 03. 避免边界错误
    - 04. 请勿对非可平凡复制的实参使用 memset 或 memcpy
## 06. 字符串
    - 01: 使用 std::string 以拥有字符序列
    - 02: 使用 std::string_view 或 gsl::span<char> 以指代字符序列
    - 03: 使用 zstring 或 czstring 以指代 C 风格、以零结尾的字符序列
    - 04: 使用 char* 以指代单个字符
    - 05: 使用 std::byte 以指代并不必须表示字符的字节值
    - 06: 当需要实施相关于文化地域的操作时，使用 std::string
    - 07: 当需要改动字符串时，使用 gsl::span<char> 而不是 std::string_view
    - 08: 为作为标准库的 string 类型的字符串字面量使用后缀 s
## 07. `iostream`
    - 01. 仅在必要时才使用字符层面的输入
    - 02. 当进行读取时，总要考虑非法输入
    - 03. 优先使用 `iostream` 进行 I/O
    - 04. 除非你使用了 `printf` 族函数，否则要调用 `ios_base::sync_with_stdio(false)`
    - 05. 避免使用 `endl`
## 08. 正则表达式
## 09. 时间
## 10. C 标准库
    - 01. 请勿使用 `setjmp` / `longjmp`